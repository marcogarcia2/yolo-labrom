import numpy as np
import cv2
import os
import random
import matplotlib.pyplot as plt
    

def generate_yolo_annotation(masks_paths: list, labels_path: str, class_id: int=0, epsilon: float=7.0):
    
    """
    Given a list of masks paths, generate YOLO annotations for segmentation and saves them in an output folder.
    """

    for mask_path in masks_paths:
        mask = cv2.imread(mask_path, cv2.IMREAD_GRAYSCALE)

        if mask is None:
            print(f"Error loading {mask_path}.")
            continue
        
        # Detect mask contours 
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        if not contours:
            print(f"No contour found for mask {mask_path}.")
            continue

        for contour in contours:

            # Simplifies the contour using Ramer-Douglas-Peucker
            simplified_contour = cv2.approxPolyDP(contour, epsilon, True)

            # Normalizing the points to YOLO format
            h, w = mask.shape
            points = simplified_contour.reshape(-1, 2)  # Converter para lista de pontos (x, y)
        
            # Normalizing the coordinates [0,1]
            points_normalized = [(x / w, y / h) for x, y in points]
            
            # Generating the annotation itself
            annotation = f"{class_id} " + " ".join([f"{x:.6f} {y:.6f}" for x, y in points_normalized]) + "\n"

            # Saving it to the corresponding file
            label_name = os.path.splitext(os.path.basename(mask_path))[0].replace('_mask', '') + ".txt"
            with open(os.path.join(labels_path, label_name), "a") as f:
                f.write(annotation)

    

def polygon_visual_inspection(images_folder: str, labels_folder: str, n: int=5):
    
    """
    Visualizes the polygons generated by the labels N times. 
    """
    
    red = (0,0,255)

    images_list = [os.path.join(images_folder, f) for f in os.listdir(images_folder) if f.endswith((".jpg"))]
    selected_images = random.sample(images_list, n)

    for image_path in selected_images:
        
        label_path = image_path.replace(".jpg", ".txt").replace(images_folder, labels_folder)

        img = cv2.imread(image_path)

        if img is None:
            print(f"Error loading {image_path}.")
            continue

        labels = []
        with open (label_path, 'r') as label_file:
            lines = label_file.readlines()
            for line in lines:
                labels.append(line.strip())

        for label in labels:
            
            # Converting YOLO coordinates do pixels
            h, w, _ = img.shape
            
            values = label.split()
            values = list(map(float, values))

            points = np.array(values[1:])
            points = points.reshape(-1, 2)  # Transforming data to a list of points (x,y)
            points[:, 0] *= w  # Converting to real dimension
            points[:, 1] *= h  # Converting to real dimension

            thickness = int(0.005 * max(h,w))

            # Drawing the polygon
            points = points.astype(np.int32)
            cv2.polylines(img, [points], isClosed=True, color=red, thickness=thickness)
            for point in points:
                cv2.circle(img, point, thickness*2, red, -1)

        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        # Exibir a imagem com o pol√≠gono
        plt.imshow(img_rgb)
        plt.axis(False)
        plt.show()




def resize_with_padding(img: np.array, target_size: int=640):
    """"
    Resizes the image with padding, in order to preserve proportions.
    """
    h, w, _ = img.shape 
    scale = target_size / max(w, h) 
    new_w, new_h = int(w * scale), int(h * scale)

    img_resized = cv2.resize(img, (new_w, new_h), interpolation=cv2.INTER_LINEAR)

    pad_w = (target_size - new_w) // 2
    pad_h = (target_size - new_h) // 2

    img_padded = np.zeros((target_size, target_size, 3), dtype=np.uint8)
    img_padded[pad_h:pad_h+new_h, pad_w:pad_w+new_w] = img_resized

    return img_padded


def resize_all_with_padding(origin_path: str, dest_path: str, size: int):
    """"
    Resizes with padding all images in given directories.
    """
    # Resizing all images
    for img_name in os.listdir(origin_path):
        if img_name.endswith((".jpg", ".png", ".jpeg")):
            img_path = os.path.join(origin_path, img_name)
            img = cv2.imread(img_path)

            if img is not None:
                # img_new = cv2.resize(img, (640, 640), interpolation=cv2.INTER_LINEAR) # without padding
                img_new = resize_with_padding(img, size)
                cv2.imwrite(os.path.join(dest_path, img_name), img_new)


def rename_all(dest_path: str, masks: bool=False):
    """
    Renames all files in a directory in ascending order.
    """
    images = sorted([f for f in os.listdir(dest_path) if f.endswith((".jpg", ".png", ".jpeg"))])

    for i, img_name in enumerate(images, start=1):
        ext = os.path.splitext(img_name)[1]
        new_name = f"{i:05d}{ext}" if masks == False else f"mask_{i:05d}{ext}"
        
        old_path = os.path.join(dest_path, img_name)
        new_path = os.path.join(dest_path, new_name)
        
        os.rename(old_path, new_path)